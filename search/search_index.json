{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"/:\\ gitStream","text":"<p>gitStream automates your reviews, so you can focus human effort on what matters most. Not all Pull Requests are the same. Some reviews can be automated, like changes using a specific API (deprecated, sensitive), changes that are non-functional, like docs or tests, or even reformatting code. Automate these reviews to reduce context switches by assigning specific people to review, approve, or even merge simple changes that passed all checks, and more.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Take these three steps to see how gitStream works; later on you can learn about the .cm file, see some automation examples and learn how to create and edit your automation.</p>  GitHub GitLab BitBucket <ol> <li>Install gitStream for free in GitHub</li> <li>Configure your repository using the instructions for GitHub</li> </ol> <p>That's it! Now sit back and watch gitStream automation rules on your next PR (You don\u2019t have to merge it)</p> <p>Note</p> <p>When installing for GitHub, gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all, as it will also cover new repos you add in the future. You can change this setting at any time later.</p> <p>Coming soon</p> <p>Coming soon</p>"},{"location":"#features","title":"Features","text":"<p>\ud83d\udcd0  Building Custom Rules</p> <ul> <li>PR Complexity </li> <li>Multiple sources</li> <li>Code change variables  </li> <li>Branch details &amp; history</li> </ul> <p>\ud83e\udd16  gitStream engine</p> <ul> <li>Auto-merge PRs</li> <li>Custom PR labels</li> <li>Require specific reviewers </li> <li>Automated change requests</li> <li>Increase quality requirements </li> <li>Based on Jinja2 template engine</li> </ul>"},{"location":"#continuous-merge","title":"Continuous Merge","text":"<p>Continuous Merge (CM) is the practice of automating the merge path by classifying pull requests based on change type, size, and complexity to allow work to flow more efficiently.</p> <p>learn more about the .cm file</p> <p>automation examples</p> <p> </p>"},{"location":"automation-actions/","title":"Automation actions","text":"<p>Actions are the end results of the automation described in your <code>.cm</code> file.</p> <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"automation-actions/#overview","title":"Overview","text":"<p>gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed.</p> <ul> <li><code>add-comment</code></li> <li><code>add-label</code></li> <li><code>add-labels</code></li> <li><code>add-reviewers</code></li> <li><code>approve</code></li> <li><code>close</code></li> <li><code>merge</code></li> <li><code>set-required-approvals</code></li> <li><code>require-reviewers</code></li> <li><code>request-changes</code></li> </ul> <p>Note</p> <p>Multiple actions can be listed in a single automation. The actions are invoked one by one.</p>"},{"location":"automation-actions/#dynamic-actions-arguments","title":"Dynamic actions arguments","text":"<p>Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example:</p> <pre><code>automations:\npr_complexity:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"\n</code></pre>"},{"location":"automation-actions/#reference","title":"Reference","text":""},{"location":"automation-actions/#add-comment","title":"<code>add-comment</code>","text":"<p>This action, once triggered, adds a comment to the PR.</p> <p>This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>comment</code> Required String Sets the comment, markdown is supported example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='core/') | some }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nCore service update\n(Updates API)\n</code></pre>"},{"location":"automation-actions/#add-label","title":"<code>add-label</code>","text":"<p>This action, once triggered, adds a label to the PR.</p> <p>This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>label</code> Required String The label text any string can work <code>color</code> Optional String The color in hex, for example: <code>'FEFEFE'</code> (you can also add <code>#</code> prefix <code>#FEFEFE</code>) example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='api/') | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: api-change\n</code></pre>"},{"location":"automation-actions/#add-labels","title":"<code>add-labels</code>","text":"<p>This action, once triggered, adds a list of labels to the PR.</p> <p>This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>labels</code> Required [String] The list of text labels"},{"location":"automation-actions/#add-reviewers","title":"<code>add-reviewers</code>","text":"<p>This action, once triggered, sets a specific reviewer.</p> Args Usage Type Description <code>reviewers</code> Required or <code>team_reviewers</code> [String] Sets reviewers user name <code>team_reviewers</code> Required or <code>reviewers</code> [String] Sets reviewers teams name, without the <code>@</code> prefix <code>unless_reviewers_set</code> Optional Bool When <code>true</code>, the reviewers are not added if the PR has already assigned reviewers. It is set to <code>false</code> by default example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='src/ui/') }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [popeye, olive]\n</code></pre>"},{"location":"automation-actions/#approve","title":"<code>approve</code>","text":"<p>This action, once triggered, approves the PR for merge.</p> <p>This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable.</p> example<pre><code>automations:\nsmall_change:\nif:\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n</code></pre>"},{"location":"automation-actions/#close","title":"<code>close</code>","text":"<p>This action, once triggered, close the PR without merging.</p> example<pre><code>automations:\nclose_ui_changes_by_non_ui:\nif:\n- {{ files | match(regex=r/src\\/views/) | some }}\n- {{ pr.author_teams | match(term='ui-team') | nope }}\nrun:\n- action: add-comment@v1\nargs: comment: |\nPlease contact a member of `ui-team` team if you need to make changes to files in `src/views`\n- action: close@v1\n</code></pre>"},{"location":"automation-actions/#merge","title":"<code>merge</code>","text":"<p>Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks.</p> Args Usage Type Description <code>wait_for_all_checks</code> Optional Boolean By default <code>false</code>, so only Required checks can block merge, when <code>true</code> the action won't merge even if non-Required check fail <code>rebase_on_merge</code> Optional Boolean By default <code>false</code>, when merging use rebase mode <code>squash_on_merge</code> Optional Boolean By default <code>false</code>, when merging use squash mode example<pre><code>automations:\nsmall_change:\nif:\n- {{ files | allDocs }}\nrun:\n- action: merge@v1\nargs:\nrebase_on_merge: true\n</code></pre>"},{"location":"automation-actions/#set-required-approvals","title":"<code>set-required-approvals</code>","text":"<p>This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge.</p> Args Usage Type Description <code>approvals</code> Required Integer Sets the number of required reviewer approvals for merge for that PR example<pre><code>automations:\ndouble_review:\nif:\n- {{ files | match(regex=r/agent\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.</p>"},{"location":"automation-actions/#request-changes","title":"<code>request-changes</code>","text":"<p>This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge.</p> <p>This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable.</p> Args Usage Type Description <code>comment</code> Required [String] The desired request changes comment example<pre><code>automations:\ncatch_deprecated:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/^[+].*oldFetch\\(/') | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nYou have used deprecated API `oldFetch`, use `newFetch` instead.\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.</p>"},{"location":"automation-actions/#require-reviewers","title":"<code>require-reviewers</code>","text":"<p>This action, once triggered, requires a specific reviewer approval.</p> Args Usage Type Description <code>reviewers</code> Required [String] Sets reviewers user name, merge is blocked till approved by either of the listed users <code>team_reviewers</code> Required or <code>reviewers</code> [String] Sets reviewers teams name, without the <code>@</code> prefix <code>also_assign</code> Optional Bool <code>true</code> by default, also assign the specified users as reviewers example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(regex=r/src\\/ui\\//) | some }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: ['popeye', 'olive']\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.</p>"},{"location":"cm-file/","title":"Overview","text":"<p>Continuous Merge automation files have a <code>.cm</code> extension. In a repository,  gitStream loads and parse the <code>.cm</code> directory, which can have multiple automation files, each of which is evaluated independently.</p> <p>You can edit the <code>.cm</code> files and add your own checks and rules. Check out the Automation examples.</p>"},{"location":"cm-file/#automation-rules","title":"Automation rules","text":"<p>There are two types of automation rules: repository level rules and organization level rules. </p> <p>Repository level rules are set by creating a special <code>.cm</code> directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with <code>.cm</code>. </p> <p>Organization level rules are defined by creating a special repository named <code>cm</code> in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. </p> <p>When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier.</p> <p>An autoamtion identifier is a compistion of the CM file name and the automation name. For example when <code>safe_changes</code> is defined in <code>gitstream.cm</code> then the automation identifier shall be <code>gitstream/safe_changes</code></p> <p>Tip</p> <p>You can exclude certain repositoires per automation file using the <code>config.ignore_repositories</code></p>"},{"location":"cm-file/#repository-automation-rules","title":"Repository automation rules","text":"<p>Repository automation rules are set by creating a special <code>.cm</code> directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but ends with <code>.cm</code>. By default, you start with a single automation file <code>.cm/gitstream.cm</code>. </p> <p>Every file is parsed independently, and the parsing results are combined and executed.</p> <p>Specifically:</p> <ol> <li>Automation rules are allowed to have same name in different <code>.cm</code> files</li> <li>The <code>config</code> section is defined per <code>.cm</code> file (except <code>config.admin</code>)</li> <li>Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated)</li> </ol> <p>When configured correctly, your repository directory structure should look like that (for GitHub):</p> Repsository automation rules<pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 *.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>Note</p> <p>The <code>.cm/gitstream.cm</code> is special, as it allows for repository level configuration such as <code>config.admin</code>.</p>"},{"location":"cm-file/#organization-automation-rules","title":"Organization automation rules","text":"<p>Organization automation rules are defined by creating a special repository <code>cm</code> in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected.</p> <p>When configured correctly, the <code>cm</code> repository directory structure should look like that (for GitHub):</p> Repsository automation rules<pre><code>.\n\u251c\u2500 *.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>For each PR the following automation rules are applied:</p> <ol> <li>Repository level rules </li> <li>Organization level rules, unless with the same identifier as a repository level automation</li> </ol> <p>When organization level rules are defined, then the CI/CD will be executed on the <code>cm</code> repository on behalf of the PR repository.</p>"},{"location":"cm-file/#the-cm-automation-file","title":"The .cm automation file","text":""},{"location":"cm-file/#context-variables","title":"Context variables","text":"<p>gitStream includes a collection of variables called contexts. These variable has all the inputs you need to code your automation, including files names and paths, code that was changed or who did the change. See more here.</p>"},{"location":"cm-file/#filter-functions","title":"Filter functions","text":"<p>Filter functions are essentially callable functions that can be applied to variables. They are called with a pipe operator <code>|</code> and can take arguments inside parentheses <code>( )</code>. The logic expressions are based on Jinja2 syntax, supported by Nunjucks library.</p> <p>See more about the Nunjucks built-in filters here, and about gitStream built-in filters here.</p>"},{"location":"cm-file/#automation-actions","title":"Automation actions","text":"<p>Specify the desired automations that are triggered when all conditions are met, read more here.</p> <p>Each automation includes conditions in an <code>if</code> section and actions in a <code>run</code> section. </p> <p>Conditions: Multiple conditions can be listed for a single automation, with AND relationship between the conditions, hence all listed conditions must pass to invoke the actions. The conditions are evaluated on new Pull Requests or changes to the Pull Request.</p> <p>Actions: Multiple actions can be listed in a single automation, the actions are invoked one by one.</p> <p>PRs that are marked as Draft are ignored by default, you can change that, see <code>config</code> .</p>"},{"location":"cm-file/#schema","title":"Schema","text":"<p>The following sections are used in <code>.cm</code> file to describe the desired automations:</p> <ul> <li><code>manifest</code></li> <li><code>config</code></li> <li><code>automations</code></li> </ul>"},{"location":"cm-file/#manifest","title":"<code>manifest</code>","text":"<p>The first section in a <code>gitstream.cm</code> file is the <code>manifest</code>.</p> <pre><code>manifest: version: 1.0\n</code></pre> <p>The only field required is <code>version</code>.</p> Key Required Type Description <code>manifest</code> Y Map The manifest section root <code>manifest.version</code> Y String Specify the <code>.cm</code> spec version: 0.1, 1.0 <p>The manifest version field is used to parse the <code>.cm</code> file, in the future if breaking changes are introduced to the parser then older automation will be still supported.</p>"},{"location":"cm-file/#config","title":"<code>config</code>","text":"<p>The <code>config</code> section is optional in the <code>.cm</code> file and is used to specify configuration for the way gitStream works.</p> Key Type Default Scope Description <code>config</code> Map - per <code>.cm</code> file The config section, applies for the automations defined in the current file <code>config.admin.users</code> [String] <code>[]</code> <code>gitstream.cm</code> Admin user list (use the Git provider user names) <code>config.ignore_files</code> [String] <code>[]</code> per <code>.cm</code> file Exclude specific files <code>config.ignore_repositories</code> [String] <code>[]</code> per <code>.cm</code> file Exclude specific repositories <code>config.user_mapping</code> [String: String] <code>[]</code> per <code>.cm</code> file Key value list of Git user detailes and Git provider account names"},{"location":"cm-file/#configadminusers","title":"<code>config.admin.users</code>","text":"<p>When specified in <code>gitstream.cm</code> the <code>config.admin.users</code> allows adding admin rights, when a PR changes the <code>*.cm</code> files only, if the user is listed in <code>config.admin.users</code> the PR will be then approved by gitStream. For example, setting <code>popeye</code> as admin:</p> example<pre><code>config:\nadmin:\nusers: ['popeye'] </code></pre> <p>This configuration is valid only when used in <code>.cm/gitstream.cm</code>, when defined in other <code>.cm</code> files this configuration is ignored.</p>"},{"location":"cm-file/#configignore_files","title":"<code>config.ignore_files</code>","text":"<p>The <code>config.ignore_files</code> supports glob pattern matching that contains list of files to ignore, for example:</p> example<pre><code>config:\nignore_files:\n- 'yarn.lock'\n- 'package-lock.json'\n- 'openapi.json'\n- 'ui/src/**/*Model.d.ts'\n</code></pre>"},{"location":"cm-file/#configignore_repositories","title":"<code>config.ignore_repositories</code>","text":"<p>The <code>config.ignore_repositories</code> contains list of repositories to ignore, for example:</p> example<pre><code>config:\nignore_repositories:\n- services\n- common\n</code></pre> <p>For the listed repositories, the automation defined in the CM file shall not apply.</p>"},{"location":"cm-file/#configuser_mapping","title":"<code>config.user_mapping</code>","text":"<p>Accepts list of key value strings.</p> <p>For example, when using <code>rankByGitBlame</code> or <code>explainRankByGitBlame</code> Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the <code>config.user_mapping</code>. This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts:</p> example<pre><code>config:\nuser_mapping:\n- 'Popeye Man &lt;popeye@invalid.com&gt;': 'popeye-the-salyor-man'\n- 'Popeye Man &lt;popeye2@invalid.com&gt;': 'popeye-the-salyor-man'\n- 'Popeye': null\n</code></pre> <p>When using <code>rankByGitBlame</code> to assign reviewers automatically with <code>add-reviewers@v1</code> then mapping users to <code>null</code> is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team.</p> <p>On the other hand, when using <code>explainRankByGitBlame</code> with <code>add-comment@v1</code> it still shows these users details in the PR comment suggestion as this info might be valuable by itself.</p> <pre><code>- action: add-reviewers@v1\nargs: # (1)\nreviewers: {{ repo | rankByGitBlame(gt=25) }} - action: add-comment@v1 args: # (2)\ncomment: |\n{{ repo | explainRankByGitBlame(gt=25) }} </code></pre> <ol> <li><code>rankByGitBlame</code> will drop <code>null</code> users</li> <li><code>explainRankByGitBlame</code> will NOT drop <code>null</code> users</li> </ol>"},{"location":"cm-file/#automations","title":"<code>automations</code>","text":"<p>The <code>automations</code> section defines the automations and their conditions. </p> <pre><code>automations:\nmark_small_pr:\nif:\n- {{ checks.size.is.xsmall }}\nrun:\n- action: add-label@v1\nargs:\nlabel: xsmall\n</code></pre> <p>Each automation includes its name, and few fields: <code>if</code> and <code>run</code>.</p> Key Required Type Description <code>automations</code> Y Map The automations section root <code>automations.NAME</code> Y Map User defined name of the automation, can be any string <code>automations.NAME.if</code> Y Map List of conditions with AND relationship <code>automations.NAME.run</code> Y Map Actions to run if all conditions are met, invoked one by one <p>The <code>if</code> field includes the list of conditions. The conditions are checked when a pull request  is opened or changed, if all the conditions pass, the automation is executed.</p> <p>The <code>run</code> field includes the automation to execute. It includes the following fields:</p> Key Required Type Description <code>action</code> Y String The action pointer <code>engine</code> N String The action engine, default is <code>gitstream</code> <code>args</code> N List The action inputs list <p>For <code>gitstream</code> engine, the action is specified by: <code>name@version</code></p> <p>gitStream supported actions, see actions.</p>"},{"location":"cm-file/#reusing-checks","title":"Reusing checks","text":"<p>You can define an accessory section, e.g. <code>checks</code>, that defines common conditions, and reuse.  </p> <pre><code>size:\nis:\nsmall: {{ branch.diff.size &lt; 20 }}\nmedium: {{ branch.diff.size &gt;= 20 and branch.diff.size &lt; 100 }}\nlarge: {{ branch.diff.size &gt;= 100 }}\nautomations:\napprove_small:\nif:\n- {{ size.is.small }}\nrun:\n- action: approve@v1\nmark_small_medium:\nif:\n# Check that the PR is either small or medium size \n- {{ size.is.small or size.is.medium }}\n# AND its less than 5 minutes review (estimated) \n- {{ branch | estimatedReviewTime &lt;= 5 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'good-size'\n</code></pre>"},{"location":"cm-syntax/","title":"CM Syntax","text":"<p>gitStream CM syntax defines a powerful and flexible language that enables users to write automation rules and customize their workflows. In this guide, we'll walk you through the basics of CM syntax and provide examples to help you get started.</p>"},{"location":"cm-syntax/#how-to-read-the-different-sections","title":"How to read the different sections?","text":"<p>Every CM file must have a single <code>automations</code> section, which is where you define your automation rules. In this section, you can create dictionaries that specify the conditions and actions of your automation rules. You can name each automation rule as you desire, making it easy to keep track of different rules in your file. </p> <p>In the example below, <code>safe_changes</code> is an automation. You can name each automation rule as you desire. In the example below, <code>safe_changes</code> can have any other name you like as long as it is a valid YAML string.</p> <p>You can also define user defined accessory sections. These sections can contain common variables and expressions that you can use to simplify your automation rule syntax and reuse it in different rules within the same file. This can help make your automation rules more readable and maintainable.</p> <p>In the example below we have defined <code>is.formatting</code>, <code>is.docs</code> and <code>is.tests</code>.</p> <pre><code>automations:\nsafe_changes: # (1)\nif:\n- {{ is.formatting or is.docs or is.tests }}\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-changes'\n- action: approve@v1\nis: #(2)\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\n</code></pre> <ol> <li>User defined string that used to name the automation rule</li> <li>User defined accessory section</li> </ol> <p>The <code>is.formatting</code> and the other terms in the line are not the actual expression, it is just a way to make the long expression shorter or reuse it.</p> <p>It actually refers to the section at the bottom of the example that has the actual expressions:</p> <pre><code>is:\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\n</code></pre> <p>You can change the <code>is</code> or the keys below it (e.g. <code>formatting</code>) to any word (except some reserved words) you like and use that in your expressions \u2013 much like variables\u2026</p>"},{"location":"cm-syntax/#how-to-read-an-expression","title":"How to read an expression?","text":"<p>We will explore how gitStream verifies that only documents have been modified by using the following expression:</p> <pre><code># The pipe symbol `|` functions like a Unix terminal pipe, \n# the expression can be interpreted as `allDocs(files)`\n{{ files | allDocs }}\n</code></pre> <p>In this expression, the <code>file</code> is a context variable that holds the files' full path for all the changes in the PR. The function <code>allDocs</code> is defined here and return <code>true</code> when files extensions are: <code>md</code>, <code>mkdown</code>, <code>txt</code>, <code>rst</code>, except for <code>requirements.txt</code>.</p>"},{"location":"cm-syntax/#using-logic-operators","title":"Using logic operators","text":"<p>Following in this example to invert the logic you can use <code>not</code> - a reserved word that invert boolean results: </p> <pre><code>{{ not (is.formatting or is.docs or is.tests) }}\n</code></pre>"},{"location":"cm-syntax/#reserved-words","title":"Reserved words","text":"<p>gitStream reserved words:</p> <p><code>manifest</code> <code>config</code> <code>automations</code> <code>every</code> <code>filter</code> <code>includes</code> <code>map</code> <code>match</code> <code>nope</code> <code>reject</code> <code>some</code> <code>allDocs</code> <code>allImages</code> <code>allTests</code> <code>estimatedReviewTime</code> <code>extensions</code> <code>explainRankByGitBlame</code> <code>isFirstCommit</code> <code>isFormattingChange</code> <code>matchDiffLines</code> <code>rankByGitActivity</code> <code>rankByGitBlame</code></p> <p>Nunjucks reserved words:</p> <p><code>e</code> <code>if</code> <code>for</code> <code>asyncEach</code> <code>asyncAll</code> <code>macro</code> <code>set</code> <code>extends</code> <code>block</code> <code>include</code> <code>import</code> <code>raw</code> <code>verbatim</code> <code>filter</code> <code>call</code> <code>abs</code> <code>batch</code> <code>capitalize</code> <code>center</code> <code>default</code> <code>dictsort</code> <code>dump</code> <code>escape</code> <code>first</code> <code>float</code> <code>forceescape</code> <code>groupby</code> <code>indent</code> <code>int</code> <code>join</code> <code>last</code> <code>length</code> <code>list</code> <code>lower</code> <code>nl2br</code> <code>random</code> <code>reject</code> <code>rejectattr</code> <code>replace</code> <code>reverse</code> <code>round</code> <code>safe</code> <code>select</code> <code>selectattr</code> <code>slice</code> <code>sort</code> <code>string</code> <code>striptags</code> <code>sum</code> <code>title</code> <code>trim</code> <code>truncate</code> <code>upper</code> <code>urlencode</code> <code>urlize</code> <code>wordcount</code></p>"},{"location":"cm-syntax/#syntax-highlighting","title":"Syntax highlighting","text":"<p>You can add support for <code>.cm</code> in your code editor, see FAQ.</p>"},{"location":"context-variables/","title":"Context variables","text":"<p>Context variable are the inputs for the automation conditions or checks.</p> <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"context-variables/#overview","title":"Overview","text":""},{"location":"context-variables/#context","title":"Context","text":"<p>gitStream includes a collection of variables called contexts. </p> <ul> <li><code>branch</code></li> <li><code>files</code></li> <li><code>source</code></li> <li><code>repo</code></li> <li><code>pr</code></li> </ul>"},{"location":"context-variables/#structures","title":"Structures","text":"<p>The following structures are used in the context objects:</p> <ul> <li><code>GitBlame</code></li> <li> <code>Check</code></li> <li><code>Contributor</code></li> <li><code>FileDiff</code></li> <li><code>FileMetadata</code></li> <li><code>GeneralComment</code></li> <li><code>LineComment</code></li> </ul> Example of a context object <p>Example of a context object for a PR that changed few lines in a <code>README.md</code> file:</p> <pre><code>{\n\"branch\": {\n\"name\": \"new-feature-branch\",\n\"base\": \"main\",\n\"diff\": {\n\"size\": 50,\n\"files_metadata\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"deletions\": 0,\n\"additions\": 2\n}\n]\n},\n\"num_of_commits\": 1\n},\n\"source\": {\n\"diff\": {\n\"files\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"diff\": \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\",\n\"original_content\": \"This project \\n\",\n\"new_content\": \"This project \\n\\n## Intro\"\n}\n]\n}\n},\n\"repo\": {\n\"contributors\": {\n\"popeye\": \"46\",\n\"olive\": \"6\"\n}\n},\n\"files\": [\n\"README.md\"\n]\n}\n</code></pre>"},{"location":"context-variables/#reference","title":"Reference","text":""},{"location":"context-variables/#branch","title":"<code>branch</code>","text":"<p>The <code>branch</code> context contains info regarding the branch changes compared to the base branch. </p> <p>Note</p> <p>compared to the <code>source</code> context does not include actual source code.</p> Values Type Description <code>branch</code> Map Includes the info related to the current branch <code>branch.author</code> String The branch author (the user that did first commit in the branch). The formatted like author in <code>git-log</code>, e.g. <code>Popeye &lt;popeye@acme.com&gt;</code> <code>branch.author_name</code> String The branch author name <code>branch.author_email</code> String The branch author email <code>branch.base</code> String The main branch, <code>main</code> <code>branch.commits.messages</code> [String] A list with all the commit messages in this branch <code>branch.diff.size</code> Integer The sum of line changed: additions, edits and deletions <code>branch.diff.files_metadata</code> <code>FileMetadata</code> List of changed files including their relative path <code>branch.name</code> String The current branch, <code>feature-123-branch</code> <code>branch.num_of_commits</code> Integer The number of commits in the branch <p>The branch context doesn't include any source code, but only related metadata.</p> <p>Example for using <code>branch.name</code> and <code>branch.author</code> to automatically approve and merge version bumps.</p> <pre><code>automations:\ndependabot:\nif:\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-dependabot\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>"},{"location":"context-variables/#files","title":"<code>files</code>","text":"<p>The <code>files</code> context includes the list of changed files in the branch compared to the main branch.</p> Values Type Description <code>files</code> [String] List of all changed files with their full path <p>For example, a typical <code>files</code> context can look like this: </p> <pre><code>[\n\"README.md\",\n\"package.json\",\n\"src/app.js\",\n\"src/index.js\",\n\"docs/examples.md\"\n]\n</code></pre> <p>Example for checking if certain changes are made:</p> <pre><code>automations:\nui_review:\nif:\n- {{ files | match(list=ui_templates_files) | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [GitHubUser1, GitHubUser2]\nui_templates_files:\n- resources/app/ui_template.yml\n- resources/app/role_template.yml\n- resources/app/account_template.yml\n</code></pre>"},{"location":"context-variables/#pr","title":"<code>pr</code>","text":"<p>The <code>pr</code> context includes metadata related to the pull request.</p> Values Type Description <code>pr</code> Map Includes the info related to the PR <code>pr.approvals</code> [String] The of reviewers that approved the PR <code>pr.author</code> String The PR author name <code>pr.author_teams</code> String The teams which the PR author is member of <code>pr.checks</code> <code>Check</code> List of checks, names and status <code>pr.created_at</code> String The date and time the PR was created <code>pr.draft</code> Bool <code>true</code> when the PR is marked as Draft/WIP <code>pr.description</code> String The PR description text <code>pr.general_comments</code> <code>GeneralComment</code> TBD <code>pr.line_comments</code> <code>LineComment</code> TBD <code>pr.provider</code> String The Git cloud provider name, e.g. <code>GitHub</code>, <code>GitLab</code> etc. <code>pr.reviewers</code> [String] The list of reviewers set for this PR <code>pr.status</code> String The PR status: <code>open</code>, <code>requested-changes</code>, <code>approved</code>, <code>merged</code> <code>pr.title</code> String The PR title <code>pr.updated_at</code> String The date and time the PR was last updated <p>Example for checking the PR title includes a Jira ticket:</p> <pre><code>automations:\ncheck_jira_ticket:\nif:\n- {{ not has.jira_ticket }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"missing-ticket\"\ncolor: 'F6443B'\nhas:\njira_ticket: {{ pr.title | includes(regex=r/^\\[?\\w{3,4}-\\d{1,6}\\]?(\\s|-|_).{20,}$/) }}\n</code></pre>"},{"location":"context-variables/#repo","title":"<code>repo</code>","text":"<p>The <code>repo</code> context includes metadata related to the repo.</p> Values Type Description <code>repo</code> Map Includes the info related to the current repo <code>repo.git_activity</code> <code>GitActivity</code> Per file and user, the number of lines changed every week for the last 52 weeks <code>repo.age</code> Integer Number of days since first commit (of any user) <code>repo.author_age</code> Integer number of days since first commit to this repo <code>repo.blame</code> <code>GitBlame</code> The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the <code>ratio</code> field <code>repo.contributors</code> <code>Contributor</code> List of contributors in the repo"},{"location":"context-variables/#source","title":"<code>source</code>","text":"<p>The <code>source</code> context includes a list of <code>FileDiff</code> objects that can be used to get insights based on code changes. The changes compared to the latest main branch. </p> Values Type Description <code>source.diff.files</code> <code>FileDiff</code> List of changed files with their code changes <p>The source context include all code changes, it is not safe to share it with unknown services.</p>"},{"location":"context-variables/#check-structure","title":"<code>Check</code> structure","text":"<p> Coming soon</p> <pre><code>{\n\"name\": String, # The check name\n\"status\": String, # The check status: `queued`, `in_progress`, `completed`\n\"conclusion\": String, # The check conclusion: `action_required`, `cancelled`, `failure` `neutral`, `success`, `skipped`, `stale`, `timed_out`\n} </code></pre>"},{"location":"context-variables/#contributor-structure","title":"<code>Contributor</code> structure","text":"<p>The <code>repo.contributors</code> mapping includes a list of <code>Contributor</code>, where the user name is used as dynamic key:</p> <pre><code>{\nUSER_NAME: Integer # Number of commits\n} </code></pre>"},{"location":"context-variables/#filediff-structure","title":"<code>FileDiff</code> structure","text":"<p>The <code>source.diff.files</code> mapping includes a list of <code>FileDiff</code>:</p> <pre><code>{\n\"diff\": String, #  The content in diff format `+` for additions, `-` for deletions\n\"new_content\": String, # The new content in this branch\n\"new_file\": String, # The name of the file after the changes, including its path\n\"original_content\": String, #  The content as is in the `main` branch\n\"original_file\": String, #  The name of the file before the changes, including its path\n} </code></pre>"},{"location":"context-variables/#filemetadata-structure","title":"<code>FileMetadata</code> structure","text":"<p>The <code>branch.diff.files_metadata</code> mapping includes a list of <code>FileMetadata</code>:</p> <pre><code>{\n\"additions\": Integer, # The number of lines edited or added to the file\n\"deletions\": Integer, # The number of lines removed from the file  \"file\": String, # The name of the file before the changes, including its path\n} </code></pre> <p>For example, sum additions in javascript code files:</p> <pre><code>{{ branch.diff.files_metadata | filter(attr='new_file', regex=r/\\.js$|\\.ts$/) | map(attr='additions') | sum }}\n</code></pre>"},{"location":"context-variables/#generalcomment-structure","title":"<code>GeneralComment</code> structure","text":"<pre><code>{\n\"commenter\": String, # The user that add the comment\n\"content\": String, # The comment body    \"created_at\": String, # The time on which the comment was created\n\"updated_at\": String, # The time on which the comment was last updated\n\"state\": String, # either 'CHANGES_REQUESTED', 'COMMENT', 'APPROVE' or 'PENDING'\n} </code></pre>"},{"location":"context-variables/#gitactivity-structure","title":"<code>GitActivity</code> structure","text":"<p>This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks.</p> <pre><code>{\nFILE_NAME: # The file name and path\n{ # The git user identifier (String)\nGIT_USER: {\n\"week_INDEX\": Integer # Number of lines changed that week\n# ... for the last 52 weeks }\n}\n}\n</code></pre> <p>For example: </p> <pre><code>{\n\"src/utils/service.js\": {\n\"popeye &lt;popeye@acme.com&gt;\": {\n\"week_1\": 20, \"week_2\": 15, \"week_10\": 250\n},\n\"olive &lt;olive@acme.com&gt;\": {\n\"week_1\": 3, \"week_3\": 50, \"week_52\": 250\n}\n},\n\"README.md\": {\n\"popeye &lt;popeye@acme.com&gt;\": {\n\"week_2\": 15, \"week_3\": 10\n}\n}\n}\n</code></pre>"},{"location":"context-variables/#gitblame-structure","title":"<code>GitBlame</code> structure","text":"<p>For each file, a list of user's blame ratio.</p> <pre><code>{\nFILE_NAME: # The file name and path\n{ # The git user identifier (String)\nGIT_USER: Integer, # Precentage 0-100, ratio of user's lines / total lines in file\n}\n}\n</code></pre> <p>For example: </p> <pre><code>{\n\"src/utils/service.js\": {\n\"popeye &lt;popeye@acme.com&gt;\": 78,\n\"olive &lt;olive@acme.com&gt;\": 22,\n},\n\"README.md\": {\n\"popeye &lt;popeye@acme.com&gt;\": 13,\n\"olive &lt;olive@acme.com&gt;\": 22,\n\"brutus &lt;brutus@acme.com&gt;\": 65,\n}\n}\n</code></pre>"},{"location":"context-variables/#linecomment-structure","title":"<code>LineComment</code> structure","text":"<pre><code>{\n\"commenter\": String, # The user that add the comment \"content\": String, # The comment body    \"created_at\": String, # The time on which the comment was created    \"updated_at\": String, # The time on which the comment was updated    \"start_line\": Integer, # The first line marked for this comment    \"end_line\": Integer, # The last line marked for this comment    }\n</code></pre>"},{"location":"custom-filters/","title":"Custom filters","text":"<p>Custom filters are implemented in JavaScript.</p> <p>Attention</p> <p> Coming soon</p> <p>You can add custom filters by editing the <code>.cm/filters.js</code> file in your repo.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u2502  \u2514\u2500 filters.js \n</code></pre>"},{"location":"custom-filters/#adding-filters","title":"Adding filters","text":"<p>Filters can have input arguments and return a result which can be any valid JavaScript type.</p> <p>An example for a <code>.cm/filters.js</code>:</p> <pre><code>export default {\n// The includes() method determines whether an array includes a \n// certain value among its entries, returning true or false.\nmyIncludes: (list, term) =&gt; {\nreturn list.includes(term);\n},\n// Determine if a number is even or odd\nisOdd: (n) =&gt; {\nreturn parseInt(n) % 2 == 0;\n}\n}\n</code></pre> <p>Once filters are added it can be used in the <code>.cm</code> files, for example using <code>isOdd</code> filter looks like this:</p> <pre><code>{{ branch.diff.size | isOdd }}\n</code></pre>"},{"location":"custom-filters/#using-npm-packages","title":"Using npm packages","text":"<p>The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used:</p> <ul> <li><code>child_process</code></li> </ul>"},{"location":"custom-filters/#using-external-tools-results","title":"Using external tools results","text":"<p>Tip: cache result to local file system and reuse in CI/CD</p> <pre><code>const { exec } = require('child_process');\nexec('npm run test | wc -l', (err, stdout, stderr) =&gt; {\nif (err) {\n// node couldn't execute the command\nreturn;\n}\n// the *entire* stdout and stderr (buffered)\nconsole.log(`stdout: ${stdout}`);\nconsole.log(`stderr: ${stderr}`);\nreturn 123;\n});\n</code></pre> <p>For example:</p> <pre><code># access coverage results\ncoverage:\nis:\n# npm run test -&gt; /file/here \nenough: {{ source | my_coverage &gt; 80 }} # 2 user's filter \n</code></pre>"},{"location":"dry-run-mode/","title":"Dry-run mode","text":"<p>gitStream runs automations as described in <code>.cm/*.cm</code> in the main branch. </p> <p>To allow testing and experimenting with new rules, gitStream supports dry-run mode. When you commit changes to <code>.cm/*.cm</code> in a PR branch, gitStream will switch to dry-run mode.</p> <p>In dry-run mode gitStream will stop executing automation rules described in the main branch for this PR, instead gitStream will parse the automation rules described in the <code>.cm/*.cm</code> of the PR branch and add a comment in the PR that describes all the automations actions \u2013 without executing the actions.</p> <p>Note</p> <p>When in dry-run mode, changes to the <code>.cm/*.cm</code> file are ignored when calculating the conditions to help focus on setting the right automations</p> <p></p> <p>Once you are satisfied with the results, you can merge the <code>.cm/*.cm</code> into the main branch to enable all new changes.</p> <p></p>"},{"location":"examples/","title":"Examples","text":"<p>Here are some examples of actions that can be applied on repositories by gitStream.</p> <p>Tip</p> <p>See full list on the gitStream repository.</p>"},{"location":"examples/#review-efficiency","title":"Review Efficiency","text":""},{"location":"examples/#label-prs-by-complexity","title":"Label PRs by complexity","text":"<p>Automatically add a color-coded label to PRs with the estimated review time.</p> <p>When used, each PR will be annotated with this label. When there are new commits to the PR, gitStream manage the label and replace it with an updated review time when needed.</p> <p></p> <pre><code>automations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is assigned to `calc.etr` which is used in the automation above.\n# You can add as many keys as you like.\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#approve-safe-changes","title":"Approve safe changes","text":"<p>PRs that include only documentation changes are verified and approved by gitStream. In the example below, marked in yellow, the <code>files</code> context is checked by <code>allDocs</code> filter that verifies there are only document files. PRs that pass the check are approved by gitStream.</p> <p></p> <p>Check out the functions to learn more:</p> <ul> <li><code>isFormattingChange</code></li> <li><code>allDocs</code></li> <li><code>allTests</code></li> <li><code>allImages</code></li> </ul> <pre><code>automations:\nsafe_changes:\nif:\n- {{ is.formatting or is.docs or is.tests or is.asset }}\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-changes'\n- action: approve@v1\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is is assigned to `is.formatting`, `is.docs` and `is.tests` which is \n# used in the automation above. You can add as many keys as you like.\nis:\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\nasset: {{ files | match(regex=r/\\.(png|svg|gif|css)$/) | every }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#review-quality","title":"Review Quality","text":""},{"location":"examples/#like-codeowners-but-better","title":"Like CODEOWNERS but better","text":"<p>With gitStream you can define your sensitive areas, set reviewers, while allowing faster merge time for non-sensitive changes.</p> <p>The <code>nope</code> filter is used to make sure no change is in a sensitive file.</p> <p>Tip</p> <p>You can also use regex instead of normal strings, see here</p> <pre><code>automations:\napprove_non_sensitive:\nif:\n- {{ files | match(list=sensitive) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: 'non-sensitive'\ncolor: '#2CA44E'\n- action: approve@v1\nrequire_review:\nif:\n- {{ files | match(list=sensitive) | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nteam_reviewers: ['a-team']\n- action: set-required-approvals@v1\nargs:\napprovals: 1\nsensitive:\n- src/app/auth/\n- src/app/routing/\n- src/app/resources/\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#review-prs-with-code-experts","title":"Review PRs with Code Experts","text":"<p>Not every review is equal, getting the right one is important to get high quality feedback. </p> <p>Overall, selecting the right reviewer for your pull request is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. The <code>codeExperts</code> filter (learn more here) can help simplify this process by highlighting the most qualified contributors based on their activity in the relevant code area.</p> <pre><code>automations:\ncode_experts:\nif: - true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainCodeExperts(gt=10) }}\n</code></pre> <p>  Download and add to your repo .cm directory </p> <p>Using <code>explainCodeExperts</code> shows the resulting data in the PR comment.</p> <p></p> <p>Last, the <code>codeExperts</code> assigns the code experts to review the PR automatically.</p> <p>You can read more on both in the function filter page.</p>"},{"location":"examples/#mark-prs-without-tests","title":"Mark PRs without tests","text":"<p>PRs that don't have tests changes can be marked automatically.</p> <p>When a PR is opened without any tests, this label is added:</p> <p></p> <p>Once the tests are added and committed, gitStream automatically removes the label:</p> <p></p> <pre><code>automations:\nno_tests:\nif:\n- {{ files | match(regex=r/(test|spec)/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: 'missing-tests'\ncolor: '#E94637'\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#require-2-approvals-for-complex-prs","title":"Require 2 approvals for complex PRs","text":"<p>Automatically require 2 reviewers for PRs that have more than 100 lines of code changed under the <code>src</code> directory.</p> <p>This ability can be very useful if you want to have more approvals for certain PRs, but rather than increasing the required approvals for all PRs using GitHub repo settings, it allows doing that only for specific PRs.</p> <p></p> <p>Multiple conditions in the <code>if</code> section has AND relationship and must all be true for the automation to execute.</p> <pre><code>automations:\ndouble_review:\nif:\n- {{ branch | estimatedReviewTime &gt;= 30 }}\n- {{ files | length &gt;= 10 }}\n- {{ files | match(regex=r/src\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre> <p>  Download and add to your repo .cm directory </p> <p>Note</p> <p>gitStream should be set as required check in the repo so it can block merge</p>"},{"location":"examples/#share-knowledge","title":"Share knowledge","text":"<p>When setting <code>lt</code> to 50, which stands for the less-than sign: <code>&lt;</code>, only those who contributed less than 50% of lines overall are selected. Applying <code>random</code> will pick one from the list.</p> <pre><code>automations:\nshare_knowledge:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | rankByGitBlame(lt=50) | random }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#mark-prs-with-deleted-files","title":"Mark PRs with deleted files","text":"<p>When files are removed entirely you want to be sure it is not by accident, mark these PRs.</p> <p></p> <pre><code>automations:\ndeleted:\nif:\n- {{ has.deleted_files }}\nrun: - action: add-label@v1\nargs:\nlabel: 'deleted-files'\ncolor: '#DF9C04'\nhas:\ndeleted_files: {{ source.diff.files | map(attr='new_file') | match(term='/dev/null') | some }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#review-policy","title":"Review Policy","text":""},{"location":"examples/#close-prs-when-touching-out-of-scope-files","title":"Close PRs when touching out-of-scope files","text":"<p>This action, once triggered, close the PR without merging.</p> <p>You can also replace <code>close</code> with <code>requested-changes</code> to leave the PR open but request to undo the UI changes.</p> <pre><code>automations:\nclose_ui_changes_by_non_ui:\nif:\n- {{ files | match(regex=r/src\\/views/) | some }}\n- {{ pr.author_teams | match(term='ui-team') | nope }}\nrun:\n- action: add-comment@v1\nargs: comment: |\nPlease contact a member of `ui-team` team if you need to make changes to files in `src/views`\n- action: close@v1\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#assign-mentors-to-new-contributors","title":"Assign mentors to new contributors","text":"<p>During the first 21 days, a contributor is assigned automatically to get reviews by specific people. By changing <code>21</code> you can add or reduce the amount of time.</p> <p>Make sure to change the reviewers according to your team members.</p> <p></p> <pre><code>automations:\njunior:\nif:\n- {{ repo.author_age &lt; 21 and (repo.age - repo.author_age) &gt;= 21 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'first-weeks'\ncolor: '#FBBD10'\n- action : add-comment@v1\nargs:\ncomment: |\nDuring your first 21 days, your team lead will be assigned to review your PRs.\n- action: add-reviewers@v1\nargs:\nreviewers: [popeye]\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#validate-new-component-has-required-field","title":"Validate new component has required field","text":"<p>You can define required fields for components, so when your team members adds new components they should also add the required field, <code>description</code> in the example below.</p> <pre><code>automations:\ncatch_deprecated_components:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/LambdaFunction/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/description:/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'lambda-missing-field'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\nNew `LambdaFunction` must have `description:` field.\n</code></pre>"},{"location":"examples/#request-changes-on-deprecated-apis","title":"Request changes on deprecated APIs","text":"<p>For example, assume we have an old API <code>callElvis</code> we want to switch from to a new API <code>callGaga</code>, gitStream can review and trigger a change request automatically when the PR includes use of the deprecated API.</p> <p>This pattern allows defining best practices in <code>.cm</code> code. </p> <p></p> <pre><code>automations:\ncatch_deprecated_components:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/callElvis/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'deprecated-component'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\nyou have used deprecated API, use `callingGaga` instead\n</code></pre> <p>gitStream supports iterators over arrays and dictionaries, so you can also make it more general:</p> <pre><code>automations:\n{% for item in deprecated %}\n# Automation names should be unique, therefore the iteration number postfix\ncatch_deprecated_components_{{ loop.index }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'deprecated-component'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\n`{{ item.old }}` component is deprecated, use `{{ item.new }}` instead\n{% endfor %}\n# This list includes the deprecated items\ndeprecated:\n- regex: r/callElvis/\nold: Elvis\nnew: Gaga\n- regex: r/callOldAPI/\nold: callOldAPI\nnew: callBetterAPI\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"examples/#more-examples","title":"More examples","text":"<p>More examples can be found in the gitStream repository.</p> <p>Tip</p> <p>You can boost your GitHub reputation with your new automation rule - open a PR and add it to the gitStream repository</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-permissions-needed","title":"What permissions needed?","text":"<p>In your repo permissions, make sure GitHub actions are permitted:</p> <p>Go to Repo's settings &gt; Actions &gt; General &gt; Actions permissions</p> <p>Choose which repositories are permitted to use GitHub Actions.</p> <p>[x] Allow all actions and reusable workflows</p>"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","title":"Does gitStream services have access to my code?","text":"<p>Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo.</p>"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","title":"Why does gitStream require permission to write code?","text":"<p>In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope.</p>"},{"location":"faq/#what-repos-are-supported","title":"What repos are supported?","text":"<p>Any repo in GitHub is supported. More Git providers are planned soon.</p>"},{"location":"faq/#custom-filter-functions","title":"Custom filter functions","text":"<p>Coming soon.</p>"},{"location":"faq/#is-there-cm-syntax-highlighting","title":"Is there .cm syntax highlighting?","text":"<p>The <code>.cm</code> file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines.</p> <p>Add the following line to the top of the <code>.cm</code> file (the default has it already): </p> <pre><code># -*- mode: yaml -*-\n</code></pre> <p>Get a plug-in that enable modelines, popular ones are:</p> <ul> <li>VS Code: Modelines</li> <li>Sublime Text: Emacs-like Sublime Modeline</li> <li>Vim Modeline magic</li> </ul>"},{"location":"faq/#i-have-an-issue-i-can-seem-to-solve-what-should-i-do","title":"I have an issue I can seem to solve, what should I do?","text":"<p>Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look.</p> <p>Found a bug? Create a new item in the project's issues</p>"},{"location":"filter-functions/","title":"Filter functions","text":"<p>Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates.</p> <p>Note</p> <p>Items marked with  are under development and are not available yet.</p>"},{"location":"filter-functions/#overview","title":"Overview","text":"<p>The following functions are supported in addition to the built-in functions provided by Nunjucks.</p>"},{"location":"filter-functions/#low-level-functions","title":"Low level functions","text":"Function Input Args Output <code>every</code>Checks whether all element in the list are <code>true</code> [Bool] - Bool <code>filter</code>Reduce list of items into a list of same items that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>includes</code>Check if substring match String <code>regex</code>, <code>term</code>, <code>list</code> Bool <code>map</code>Maps each object in a list into their specified attribute value [Object] <code>attr</code> [Object] <code>match</code>Maps list of items into a list of booleans that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code> <code>attr</code> [Bool] <code>nope</code>Checks whether all element in the list are <code>false</code> [Bool] - Bool <code>reject</code>Inverse of <code>filter</code>, the result list contains non-matching items [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>some</code>Checks whether at least one element in the list is <code>true</code> [Bool] - Bool"},{"location":"filter-functions/#high-level-functions","title":"High level functions","text":"Function Input Args Output <code>allDocs</code>Checks the list includes only documents files - Bool <code>allImages</code>Checks the list includes only images files - Bool <code>allTests</code>Checks the list includes only tests files - Bool <code>codeExperts</code>Get list of contributors based on expert reviewer model results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>estimatedReviewTime</code>Estimated review time in minutes branch - Integer <code>extensions</code>Lists all the unique file extensions [String] - [String] <code>explainCodeExperts</code> Short markdown text explaining codeExperts results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>explainRankByGitBlame</code> Short markdown text explaining rankByGitBlame results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>isFirstCommit</code>Checks if its the author first commit in the repo <code>repo.contributors</code> String Bool <code>isFormattingChange</code>Checks that only formatting changed [<code>FileDiff</code> ] - Bool <code>matchDiffLines</code>Match every line in diff [<code>FileDiff</code> ] <code>regex</code>, <code>ignoreWhiteSpaces</code> [Bool] <code>rankByGitActivity</code>Get list of contributors based on <code>git-commit</code> activity <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>rankByGitBlame</code>Get list of contributors based on <code>git-blame</code> results <code>repo</code> <code>gt</code>, <code>lt</code> [String]"},{"location":"filter-functions/#named-arguments","title":"Named arguments","text":"<p>Some functions supports named arguments, many of these repeat in different functions.</p> <p><code>term</code> - a single string, used as substring to match with the matched item.</p> <p><code>list</code> - a list of strings, trying to match any of the listed substrings with the matched item.</p> <p><code>regex</code> - a single string, used as regular expression to with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example <code>r/^foo.*/g</code>, for more info see Nunjucks. </p> <p><code>globs</code> - a key to an element in the <code>.cm</code> that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia.</p> <p><code>attr</code> - a key in the element to use when doing the requested operation.</p> <p>For example, the following expressions provide an identical result:</p> <pre><code>- {{ 'something' | includes(regex=r/^some.*/) }}\n- {{ 'something' | includes(term='some') }}\n- {{ 'something' | includes(list=['some']) }}\n</code></pre>"},{"location":"filter-functions/#reference","title":"Reference","text":""},{"location":"filter-functions/#every","title":"<code>every</code>","text":"<p>Checks whether all element in the list are\u00a0<code>true</code>. In case the list of elements is empty, it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>true</code> <p>For example, check that all changes are in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | every }}\n</code></pre>"},{"location":"filter-functions/#filter","title":"<code>filter</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the matching items <p>For example, check if all changes to JavaScript files are in tests directory:</p> <pre><code>{{ files | filter(regex=r/\\.js$/) | match(regex=r/tests\\//) | every }}\n</code></pre> <p>For example, check if all changes to JavaScript files are formatting:</p> <pre><code>{{ source.diff.files | filter(attr='new_file', regex=r/\\.js$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#includes","title":"<code>includes</code>","text":"<p>Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input String The list of strings to match <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Substring term to match - Output Bool <code>true</code> if search terms matches <p>Check string matches either of the terms:</p> <pre><code>{{ 'something' | includes(list=['any', 'thing']) }}\n</code></pre>"},{"location":"filter-functions/#map","title":"<code>map</code>","text":"<p>Creates a new list populated with the values of the selected attribute of every element in the input list. </p> Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs <code>attr</code> Input String Object attribute to select - Output [Object] List of the selected object attributes <p>For example, the <code>source.diff.files</code> context holds a list of <code>FileDiff</code> , each has <code>new_file</code> attribute. You can create a list of all the new file names by mapping to the <code>new_file</code> attribute and then check if there are changes to any <code>handler.js</code> file:</p> <pre><code>{{ source.diff.files | map(attr='new_file') | match(term='handler.js') | some }}\n</code></pre>"},{"location":"filter-functions/#match","title":"<code>match</code>","text":"<p>Return <code>true</code> for each element in the list that match the search term.</p> Argument Usage Type Description - Input [String][Object] The list of strings or if <code>attr</code> used the list of objects <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match <code>attr</code> Input String match a named attribute in the input object - Output [Bool] <code>true</code> for every matching item <p>For example, to check if all code changes are in the <code>tests</code> directory:</p> <pre><code>{{ files | match(regex=r/tests\\//) | every }}\n</code></pre> <p>For example, to check if there are code changes with specific function call:</p> <pre><code>{{ source.diff.files | match(attr='diff', term='myFunction') | some }}\n</code></pre>"},{"location":"filter-functions/#nope","title":"<code>nope</code>","text":"<p>The inverse of <code>every</code>, checks whether all element in the list are\u00a0<code>false</code>. In case the list of elements is empty, it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>false</code> <p>For example, check that no changes in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | nope }}\n</code></pre>"},{"location":"filter-functions/#reject","title":"<code>reject</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that does not match the given term. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the non-matching items <p>For example, check if all changes, but JavaScript files are in tests directory:</p> <pre><code>{{ files | reject(regex=r/\\.js$/) | match(regex=r/tests\\//') | every }}\n</code></pre> <p>For example, check if all changes except for <code>config.json</code> files are formatting:</p> <pre><code>{{ source.diff.files | reject(attr='new_file', regex=r/config\\.json$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#some","title":"<code>some</code>","text":"<p>Checks whether any element in the list is\u00a0<code>true</code>. In case the list of elements is empty it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when any of the items is <code>true</code> <pre><code>{{ files | match(list=['src', 'dest']) | some }}\n</code></pre>"},{"location":"filter-functions/#alldocs","title":"<code>allDocs</code>","text":"<p>Return <code>true</code> if the input list includes only documents based on file extensions.</p> <p>Doc files extensions are: <code>md</code>, <code>mkdown</code>, <code>txt</code>, <code>rst</code>, except for <code>requirements.txt</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of docs <pre><code>{{ files | allDocs }}\n</code></pre> <p>In case you want to exclude more files, like all <code>txt</code> under <code>requirements</code> directory, add another check:</p> <pre><code>{{ (files | allDocs) and (files | match(regex=r/requirements\\/.*\\.txt$/) | nope ) }}\n</code></pre>"},{"location":"filter-functions/#allimages","title":"<code>allImages</code>","text":"<p>Return <code>true</code> if the input list includes only images based on file extensions.</p> <p>Image file extensions are: <code>svg</code>, <code>png</code>, <code>gif</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of images <pre><code>{{ files | allImages }}\n</code></pre>"},{"location":"filter-functions/#alltests","title":"<code>allTests</code>","text":"<p>Return <code>true</code> if the input list includes only tests based on file's path and name.</p> <p>To identify as test the file must include the word <code>test</code> or <code>spec</code> in its name or path, it is checked using this regex: <code>[^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9]</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file tests based on name and path <pre><code>{{ files | allTests }}\n</code></pre>"},{"location":"filter-functions/#codeexperts","title":"<code>codeExperts</code>","text":"<p>When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved.</p> <p>The filter provides the list of most qualified contributors based on <code>git-blame</code> and <code>git-commit</code> results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines.</p> <p>Note</p> <p>The <code>codeExperts</code> filter function calls gitStream app API with the <code>repo</code> context to calculate the estimated review time value.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) <p>For example:</p> <pre><code>automations:\ncode_experts:\nif: - true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n</code></pre>"},{"location":"filter-functions/#estimatedreviewtime","title":"<code>estimatedReviewTime</code>","text":"<p>Returns the estimated review time in minutes based on statistical model. The model uses the amount of additions and deletions statistics for each file type with additional information about the commits and base branch.</p> <p>Note</p> <p>The <code>estimatedReviewTime</code> filter function calls gitStream app API with the <code>branch</code> context to calculate the estimated review time value.</p> <p>The following files are excluded when calculating this value:</p> Argument Usage Type Description - Input <code>branch</code> Branch meta data - Output Integer the estimated time for review in minutes <pre><code>{{ branch | estimatedReviewTime }}\n</code></pre> <p>The following files are automatically excluded from the estimated review time calculation. </p> File type Filter type Values Data Extension <code>ini</code> <code>csv</code> <code>xls</code> <code>xlsx</code> <code>xlr</code> <code>doc</code> <code>docx</code> <code>txt</code> <code>pps</code> <code>ppt</code> <code>pptx</code> <code>dot</code> <code>dotx</code> <code>log</code> <code>tar</code> <code>rtf</code> <code>dat</code> <code>ipynb</code> <code>po</code> <code>profile</code> <code>object</code> <code>obj</code> <code>dxf</code> <code>twb</code> <code>bcsymbolmap</code> <code>tfstate</code> <code>pdf</code> <code>rbi</code> <code>pem</code> <code>crt</code> <code>svg</code> <code>png</code> <code>jpeg</code> <code>jpg</code> <code>ttf</code> Data Regex <code>.*dist/.*\\.js$</code> <code>.*public/assets/.*\\.js$</code> Lock Regex <code>.*package-lock|packages\\.lock|package)\\.json$</code> Lock File <code>yarn.lock</code> <code>gemfile.lock</code> <code>podfile.lock</code> <code>cargo.lock</code> <code>composer.lock</code> <code>pipfile.lock</code> <code>gopkg.lock</code> Lock Regex <code>.*gradle\\.lockfile$</code> <code>.*lock\\.sbt$</code> Pipeline Regex <code>.*ci\\.yml$</code> <p>Tip</p> <p>You can also filter more files, using <code>config.ignore_files</code>.</p>"},{"location":"filter-functions/#extensions","title":"<code>extensions</code>","text":"<p>Expects <code>files</code> and provide a list of all unique file extensions.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output [String] List of all unique file extensions <p>For example, check that only one file type was changed:</p> <pre><code>{{ files | extensions | length == 1 }}\n</code></pre>"},{"location":"filter-functions/#explaincodeexperts","title":"<code>explainCodeExperts</code>","text":"<p>This filter helps to explain the results of <code>codeExperts</code>, the output is in Markdown format that can be used in a PR comment.</p> <p>Note</p> <p>The <code>explainCodeExperts</code> filter function calls gitStream app API with the <code>repo</code> context to calculate the estimated review time value.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining <code>codeExperts</code> results in markdown format <p>For example:</p> <pre><code>automations:\ncode_experts:\nif: - true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainCodeExperts(gt=10) }}\n</code></pre> <p>Note the comment starts with <code>|</code> and a <code>new-line</code> as <code>explainCodeExperts</code> generates a multiline comment.</p>"},{"location":"filter-functions/#explainrankbygitblame","title":"<code>explainRankByGitBlame</code>","text":"<p>This filter helps to explain the results of <code>rankByGitBlame</code>, the output is in Markdown format that can be used in a PR comment. </p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. Git users that could not be automatically mapped are marked with <code>*</code>. To map these users, you can add <code>user_mapping</code> see instructions here.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining <code>rankByGitBlame</code> results in markdown format <p>Note</p> <p>Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%.</p> <p>For example:</p> <pre><code>automations:\nthe_right_reviewer:\nif: - true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | rankByGitBlame(gt=50) }}\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainRankByGitBlame(gt=50) }}\n</code></pre> <p>Note the comment starts with <code>|</code> and a <code>new-line</code> as <code>explainRankByGitBlame</code> generates a multiline comment.</p>"},{"location":"filter-functions/#isfirstcommit","title":"<code>isFirstCommit</code>","text":"<p>Return <code>true</code> if it's the author first commit in the repo.</p> Argument Usage Type Description - Input <code>repo.contributors</code> List of contributors in the repo - Input String The contributor name - Output Bool <code>true</code> if its the first commit of the selected contributor <pre><code>if: - {{ repo.contributors | isFirstCommit(branch.author) }}\nrun: - action: add-comment@v1\nargs:\ncomment: Welcome {{branch.author}}!\n</code></pre>"},{"location":"filter-functions/#isformattingchange","title":"<code>isFormattingChange</code>","text":"<p>Return <code>true</code> if all file diffs are validated as formatting changes.</p> <p>Support source code languages: JavaScript, TypeScript, JSON, YAML and HTML.</p> <p>If changes in other formats detected, the filter will return <code>false</code>.</p> Argument Usage Type Description - Input <code>source.diff.files</code> List of file diffs - Output Bool <code>true</code> if the all code changes are non functional <pre><code>{{ source.diff.files | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#matchdifflines","title":"<code>matchDiffLines</code>","text":"<p>Checks diff for matching lines.</p> Argument Usage Type Description - Input [Object] The list of objects <code>regex</code> Input String Regex term to match with the input items, use <code>\\\\</code> for <code>\\</code> <code>ignoreWhiteSpaces</code> Input Bool <code>false</code> by default, match a named attribute in the input object <code>caseSensitive</code> Input Bool <code>true</code> by default, ignore case when matching terms - Output [Bool] <code>true</code> for every matching object <p>For example, to check if all the changes are of adding prints and ignore white spaces:</p> <pre><code>{{ source.diff.files | matchDiffLines(regex=r/^\\+.*console\\.log/, ignoreWhiteSpaces=true) | every }}\n</code></pre>"},{"location":"filter-functions/#rankbygitactivity","title":"<code>rankByGitActivity</code>","text":"<p>Get list of contributors based on <code>git-commit</code> activity.</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes each  contributor number of lines changed every week over the last 52 weeks, based on <code>git-commit</code>. </p> <p>These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. </p> <p>Then you can use the thresholds to get the right reviewer.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>weeks</code> Input Integer The number of last weeks to include <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison <p>Check if the branch author is a rookie</p> <pre><code>active_coders: {{ repo | rankByGitActivity(gt=50, weeks=12) }}\n</code></pre>"},{"location":"filter-functions/#rankbygitblame","title":"<code>rankByGitBlame</code>","text":"<p>Get list of contributors based on <code>git-blame</code> results</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes the  contributors' percentage of lines in the file, based on <code>git-blame</code>. </p> <p>This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score <p>Example of the filter output, note the output are GitHub users in the example: <pre><code>[\n\"PopeyeUser\",\n\"olive_user\",\n\"BRUTUS_USER\"\n]\n</code></pre></p> <p>Get the most significant contributors for the PR files:</p> <pre><code>contributors: {{ repo | rankByGitBlame(gt=30) }}\n</code></pre> <p>Check if the branch author is a rookie</p> <pre><code>is_rookie: {{ repo | rankByGitBlame(lt=15) | match(term=branch.author) | some }}\n</code></pre>"},{"location":"github-installation/","title":"GitHub app installation","text":""},{"location":"github-installation/#installation","title":"Installation","text":"<p>Note</p> <p>Make sure gitStream app is installed in GitHub.</p> <p>Step 1 of 2: Create a <code>.cm/gitstream.cm</code> rules file in your repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\ncode_experts:\nif: - true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainCodeExperts(gt=10) }}\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>Step 2 of 2: Create a <code>.github/workflows/gitstream.yml</code> action file in your repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref required: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 5\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v1\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre>"},{"location":"github-installation/#next-steps","title":"Next steps","text":"<p>To learn how to add your first rule, jump to the Quick Start page.</p> <p>Tip</p> <p>To allow gitStream blocking PRs from merging under certain conditions, set gitStream as required check.</p>"},{"location":"github-installation/#configuration-files","title":"Configuration files","text":"<p>Eventually, the following files should exist in each of the selected repos:</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> File and path Reason <code>.cm/*.cm</code> Under the repo's <code>.cm</code> directory, any file that ends with <code>.cm</code> will be used by gitStream to specify automation rules, you can edit these files <code>.github/workflows/gitstream.yml</code> Used by gitStream to execute automation rules in your GitHub repo so source code doesn't get to outside services"},{"location":"github-installation/#permissions","title":"Permissions","text":"<p>The required permissions are: </p> Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users"},{"location":"github-org-level/","title":"GitHub setup for organization","text":"<p>Organization level rules are defined by creating a special repository named <code>cm</code> in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. </p> <p>Step 1 of 3: Create a <code>cm</code> repository in your GitHub organization.</p> <p>Note</p> <p>Make sure gitStream app is installed for the new <code>cm</code> repository in GitHub.</p> <p>Step 2 of 3: Create a <code>gitstream.cm</code> rules file in your repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <p>Note</p> <p>Unlike the repository rules, the CM file should be placed in the repository root directory</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\ncode_experts:\nif: - true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainCodeExperts(gt=10) }}\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>Step 3 of 3: Create a <code>.github/workflows/gitstream.yml</code> action file in your <code>cm</code> repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref required: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 5\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v1\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>Once this step is completed, all your PRs from all your repositories will be processed by this GitHub action in this repo.</p>"},{"location":"github-org-level/#next-steps","title":"Next steps","text":"<p>To learn more on how this works and how to configure it, read here.</p> <p>Tip</p> <p>You need to set gitStream as required check for each repository to allow gitStream blocking PRs from merging under certain conditions, set gitStream as required check.</p>"},{"location":"github-org-level/#configuration-files","title":"Configuration files","text":"<p>Eventually, the following files should exist in the <code>cm</code> repository:</p> <pre><code>.\n\u251c\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> File and path Reason <code>*.cm</code> Under the repo's root directory, any file that ends with <code>.cm</code> will be used by gitStream to specify automation rules, you can edit these files <code>.github/workflows/gitstream.yml</code> Used by gitStream to execute automation rules in your GitHub repo so source code doesn't get to outside services"},{"location":"github-required-check/","title":"Allowing gitStream to block PRs merge","text":"<p>Note</p> <p>To be able to select <code>gitStream.cm</code> as required check it should run at least once in the repo. Make sure to open at least 1 PR before doing this setting.</p> <ol> <li>Go to repo <code>settings</code></li> <li>On the left panel select <code>Code and automation</code> &gt; <code>Branches</code> </li> <li>Set <code>Branch protection rules</code> for your desired branch </li> <li>Enable <code>Require status checks to pass before merging</code></li> <li>Search for <code>status checks in the last week for this repository</code></li> <li>Select <code>gitStream.cm</code> as required check</li> </ol> <p></p> <p></p>"},{"location":"gitlab-installation/","title":"GitLab installation","text":"<p>Warning</p> <p>Please note that the GitLab support feature is still in beta, which means that the feature set is incomplete and subject to changes.</p> <p>Prerequisites:</p> <ol> <li>GitLab runner v15 or higher</li> </ol>"},{"location":"gitlab-installation/#installation","title":"Installation","text":"<p>Step 1 of 4: Create a <code>.cm/gitstream.cm</code> rules file in the work repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\ncode_experts:\nif: - true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainCodeExperts(gt=10) }}\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>Step 2 of 4: Create a new <code>cm</code> project (repository) in your GitLab group.</p> <p>Tip</p> <p>Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend to continue with a new dedicated account (e.g. <code>gitstream-cm</code>) in GitLab and install gitStream app with it. The service account has to have <code>Maintainer</code>  role.</p> <p>Step 3 of 4: Create a <code>./.gitlab-ci.yml</code> CI/CD file in the <code>cm</code> repository default branch (usually <code>master</code> or <code>main</code>) with the following contents:</p> <pre><code># Code generated by gitStream - DO NOT EDIT\nstages:\n- gitstream-main\nimage: docker:latest\nservices:\n- docker:dind\nbefore_script:\n- docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\ngitstream-job:\nstage: gitstream-main\nonly:\nvariables:\n- $GITSTREAM_MAIN_JOB\nexcept:\nvariables:\n- $GITSTREAM_BLOCK_MERGE\nscript:\n- apk update &amp;&amp; apk add git &amp;&amp; apk add docker\n- git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/\n- cd gitstream &amp;&amp; git fetch --all &amp;&amp; git checkout $base_ref &amp;&amp; git pull &amp;&amp; ls &amp;&amp; git checkout $head_ref &amp;&amp; git pull &amp;&amp; ls\n- docker pull gitstream/rules-engine:latest\n- |\ndocker run -v $CI_PROJECT_DIR/gitstream:/code \\\n-e HEAD_REF=$head_ref \\\n-e BASE_REF=$base_ref \\\n-e CLIENT_PAYLOAD=\"$client_payload\" \\\n-e RULES_RESOLVER_URL=$resolver_url \\\n-e RULES_RESOLVER_TOKEN=$resolver_token gitstream/rules-engine\n</code></pre> <p>Step 4 of 4: Install gitStream app for GitLab.</p>"},{"location":"gitlab-installation/#next-steps","title":"Next steps","text":"<p>To learn how to add your first rule, jump to the Quick Start page.</p>"},{"location":"gitlab-installation/#configuration-files","title":"Configuration files","text":"<p>Eventually, the following files should exist in each of the selected repos:</p> <p>In the <code>cm</code> repository:</p> <pre><code>.\n\u251c\u2500 .gitlab-ci.yml\n</code></pre> <p>In your target repository:</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n</code></pre> File and path Reason <code>.cm/*.cm</code> Under the repo's <code>.cm</code> directory, any file that ends with <code>.cm</code> will be used by gitStream to specify automation rules, you can edit these files <code>.gitlab-ci.yml</code> Used by gitStream to execute automation rules in your GitLab repo so source code doesn't get to outside services"},{"location":"gitlab-installation/#permissions","title":"Permissions","text":"<p>Attention</p> <p>When renaming or adding new repositories, you must re-authenticate gitStream in GitLab</p> <p>The required permissions are: </p> Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users"},{"location":"gitlab-installation/#gitstream-actions","title":"gitStream actions","text":"<p>Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend using a new dedicated account in GitLab for installing gitStream, e.g. <code>gitstream</code></p>"},{"location":"how-it-works/","title":"How it works","text":"<p>Every time a dev opens a new Pull Request or changes a Pull Request, gitStream is triggered. Next, the <code>.cm</code> file is used to determine which automatic actions are invoked based on their conditions. The resulting actions use Git provider API to achieve the desired outcome.</p>"},{"location":"how-it-works/#overview","title":"Overview","text":"<p>In general, the next steps are common practice of changing code in repo:</p> <ol> <li>Create a feature branch </li> <li>Commit changes  </li> <li>Push branch to remote repo </li> <li>Open Pull Request </li> </ol> <pre><code>gitGraph\n  commit id: \"A\"\n  commit id: \"B\"\n  branch feature\n  commit id: \"C\"\n  commit id: \"D\"\n  commit id: \"E\"\n  checkout main\n  commit id: \"F\"\n  commit id: \"G\"</code></pre> <p>When gitStream installed and configured, whenever a new PR is opened, several actors are running:</p> <ol> <li>Git provider API</li> <li>gitStream service which you have installed from the marketplace </li> <li>gitStream CI/CD script that is placed per the Git provider requirements </li> <li>gitStream agent that is executed by the CI/CD script</li> </ol> <p>Once a new PR is opened (or changed) the following process occurs:</p> <ol> <li>gitStream gets event for the new PR </li> <li>gitStream calls the CI/CD script</li> <li>The installed action pulls and runs gitStream action <code>linear-b/gitstream-github-action@v1</code>. </li> <li>This action runs locally in the repo and relies on </li> <li>The current branch is used to check which automations are valid from <code>.cm/gitstream.cm</code></li> <li>The action calls to gitStream app with metadata</li> <li>gitStream app returns results</li> <li>The list of applicable automations are sent to the gitStream service</li> <li>gitStream service iterates over the automations and invokes each action using Git provider APIs</li> <li>The PR gets updated according to the desired automations</li> </ol> <p>At the end, the PR is ready for further review or merge.</p> <p>The following diagram describes the flow:</p> <pre><code>sequenceDiagram\n  autonumber\n  Git provider API-&gt;&gt;gitStream app: new PR\n  gitStream app-&gt;&gt;gitStream CI/CD script: run \n  activate gitStream CI/CD script\n  gitStream CI/CD script-&gt;&gt;gitStream CI/CD script: pull agent action\n  gitStream CI/CD script-&gt;&gt;gitStream in repo agent: run\n  activate gitStream in repo agent\n  gitStream in repo agent-&gt;&gt;gitStream in repo agent: parse the `.cm` rules\n  gitStream in repo agent-&gt;&gt;gitStream app: API calls (metadata read-only)\n  activate gitStream app\n  gitStream app-&gt;&gt;gitStream in repo agent: results\n  deactivate gitStream app\n  gitStream in repo agent-&gt;&gt;gitStream app: applicable automations\n  deactivate gitStream in repo agent\n  deactivate gitStream CI/CD script\n  loop per automation\n    loop per action\n      gitStream app-&gt;&gt;gitStream app: execute action\n      gitStream app-&gt;&gt;Git provider API: update PR\n    end\n   end</code></pre>"},{"location":"how-it-works/#the-branch-diff","title":"The branch diff","text":"<p>The branch diff is defined as the difference between the current branch and the most recent commit in the main branch, which is shared between both branches.</p> <pre><code>gitGraph\n  commit id: \"A\"\n  commit id: \"B\"\n  branch feature\n  commit id: \"C\"\n  commit id: \"D\"\n  checkout main\n  commit id: \"E\"\n  commit id: \"F\"\n  checkout feature\n  merge main\n  commit id: \"G\"\n  commit id: \"H\"\n  checkout main\n  commit id: \"I\"\n  commit id: \"J\"</code></pre> <p>In the example above, the diff is performed between commits <code>H</code> and <code>F</code>.</p>"},{"location":"how-it-works/#automation-results","title":"Automation results","text":"<p>Eventually, the gitStream app shows the following statuses:  </p> <p> Success - when the applicable automation finished and PR is good to go </p> <p> Neutral - when there aren't any applicable automations for the PR</p> <p> Failed - when the applicable automation finished without completion</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#first-automation-adding-labels","title":"First automation \u2013 adding labels","text":"<p>Once completed installation, each of your PRs will get a label that shows the estimated review time, with color coding as you define in the <code>cm</code> file.</p> <p>Try it yourself! Open a PR with minor change to the repository <code>README.md</code> file, you don't have to merge these changes. Once your PR is open, wait for gitStream check to finish, then your PR should get a colored labeled with <code>1 min review</code> label.</p> <p></p> <p>When sharing the PR link in Slack, your reviewer will get to see the Estimated Review Time: </p> <p></p>"},{"location":"quick-start/#marking-safe-changes","title":"Marking safe changes","text":"<p>Next, let's add a new automation that checks for <code>safe-changes</code>. In the example below, we have defined documentation changes as safe changes. </p> <p>Note</p> <p>When editing the CM file, make sure to preserve the indentation in the examples, as CM like YAML uses Python-style indentation to indicate nesting.</p> <p>You can copy the text below and overwrite the default <code>.cm/gitstream.cm</code> file content. Note the new automation rule <code>safe_changes</code>.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\nsafe_changes:\nif:\n- {{ files | allDocs }}\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-changes'\n# You can uncomment the following action to get gitStream to automatically approve \n# - action: approve@v1\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>Try it yourself! Open a PR with some minor change to the repository's <code>README.md</code> file, you don't have to merge these changes. Once your PR is open and gitStream check has finished running, you should notice that gitStream added <code>cm-changes</code> label and all the automation results are now displayed as new comment in the PR. </p> <p>Note</p> <p>You can learn more aboutdry-run mode here, but the gist of it is that gitStream switch to simulation mode to allow you a safe place to check and test new rules before you merge them to the main branch.</p> <p>If you didn't get any syntax error, you should see the dry-run comment. Once you ready to update the autaomtion rules with the latest changes, undo the <code>README.md</code> file changes, and commit and merge the changes you did to the <code>.cm/gitstream.cm</code> file in order for these changes to take effect.</p> <p>Once again, let's open a new PR with some minor change to the repository's <code>README.md</code> file, you don't have to merge these changes. After gitStream check has finished you should see the green labeled with <code>1 min review</code> label and \u2013 as you only changed a document \u2013 the <code>safe-changes</code> label will appear on the PR as well.</p>"},{"location":"quick-start/#approving-safe-changes","title":"Approving safe changes","text":"<p>To approve <code>safe-changes</code> you should use the last PR, and uncomment the <code>- action: approve@v1</code> (make sure to align the <code>-</code> list indicator of the action with the previous one) or just overwrite the <code>.cm/gitstream.cm</code> file with this content:</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\nsafe_changes:\nif:\n- {{ files | allDocs }}\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-changes'\n# You can uncomment the following action to get gitStream to automatically approve \n- action: approve@v1\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre> <p>Again, gitStream will switch to dry-run mode, and you are up for it, just merge the changes to <code>.cm/gitstream.cm</code> to get safe changes approved by gitStream for your team. </p> <p>Well done! From now on, safe changes won't require developer's time to review and approve them.</p> <p></p>"},{"location":"quick-start/#whats-next","title":"What's next","text":"<p>Once you get the hang of it, you can set up more automation rules. </p> <p>You can explore the gitStream CM syntax, or go over the examples page, there you can choose various automation such as marking PRs with no tests, assigning the right reviewer \u2013 for example changes to the Japanese translation files can be automatically assigned to the right translator\u2026</p> <p>Download automation files and add them to your repository <code>.cm/</code> directory, experiment in dry-run mode, add labels and then switch to automatic actions.</p> <p>Tip</p> <p>The <code>.cm</code> directory is located in the repository root and contains the automation files. Multiple rules files are supported.</p> <p>This is only the beginning. With gitStream, you can create rules to automate your PRs. You understand what your team needs, and gitStream will help you get there.</p>"},{"location":"quick-start/#something-missing","title":"Something missing?","text":"<p>If something is missing, create a new enhancement request in the project's issues page.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#i-cant-see-any-action-running","title":"I can't see any action running","text":"<p>Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings &gt; GitHub apps:</p> <p> In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb</p> <p>Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: </p> <ol> <li><code>.cm/gitstream.cm</code></li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p>These files need to be committed to the repository default branch (usually <code>master</code> or <code>main</code>).</p> <p>Check that you see \"gitStream workflow automation\" on the Action section in your repository:</p> <p></p> <p>Next, if you see failed action, check out the details:</p> <p></p> <p>Some organization limit which actions can run, in that case in the repository settings you should enable it:</p> <p></p> <p>Is the PR in Draft mode?</p> <p>gitStream automations won't trigger for PRs that in Draft mode.</p>"},{"location":"troubleshooting/#i-have-rules-that-should-have-blocked-merge-but-the-pr-can-be-merged-still","title":"I have rules that should have blocked merge, but the PR can be merged still","text":"<p>For example, when using the <code>set-required-approvals</code>  action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that  by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here.</p> <p></p>"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","title":"I can't set gitStream as required check","text":"<p>In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered.</p> <p>Check it under repository's Settings &gt; Branches: </p> <p></p> <p></p>"},{"location":"troubleshooting/#i-dont-want-gitstream-to-run-on-prs-that-was-generated-by-a-bot","title":"I don't want gitStream to run on PRs that was generated by a bot","text":"<p>You can edit the <code>.github/workflows/gitstream.yml</code> and uncomment the <code>if</code> line, you can edit and replace the bot name with the bot name you want to ignore (<code>dependabot[bot]</code> in the example below):</p> .github/workflows/gitstream.yml<pre><code>jobs:\ngitStream:\ntimeout-minutes: 5\n# uncomment this condition, if you don't want any automation on dependabot PRs\nif: github.actor != 'dependabot[bot]'\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v1\n</code></pre>"},{"location":"troubleshooting/#gitstream-fails-and-i-dont-understand-why","title":"gitStream fails and I don't understand why","text":"<p>gitStream check run can fail from different reasons, and these are shown in the check result. </p>"},{"location":"troubleshooting/#missing-workflow-file","title":"Missing workflow file","text":"<p>When it says <code>gitStream.cm Skipped \u2014 gitStream workflow file not found</code>, it means that the GitHub action was not found, check again that you have this file in your rpeository root: <code>.github/workflows/gitstream.yml</code>, see instructions on GitHub installation.</p>"},{"location":"troubleshooting/#syntax-error-in-the-cm-files","title":"Syntax error in the cm files","text":"<p>Clicking the <code>Details</code> button will show more information and context.</p> <p></p> <p>You can add this automation to see details on context variable.</p>"},{"location":"troubleshooting/#how-can-i-debug-expressions-and-see-their-content","title":"How can I debug expressions and see their content?","text":"<p>You can dump any context value to the PR comment. For example, to see the list of changed files, use:</p> <pre><code>automations:\nshow_changed_files:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nFILES DUMP {{ files | dump | safe }}\nJS FILES DUMP {{ files | filter(regex=r/\\.js$/) | dump | safe }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"troubleshooting/#gitstream-fails-with-syntax-error-after-adding-new-rules","title":"gitStream fails with syntax error after adding new rules","text":"<p>IntelliJ IDEA has automatic code styling for YAML that can break the <code>.cm</code> syntax, check the following Settings/Preferences | Editor | Code Style | YAML --&gt; Spaces | Code braces and make sure it is unchecked.</p> <p></p> <p>VS Code YAML plugin by Red Hat extension <code>[vscode-yaml](https://github.com/redhat-developer/vscode-yaml)</code> has automatic code styling for YAML that can break the <code>.cm</code> syntax, make sure you disable <code>bracketSpacing</code> <pre><code>{\n\"yaml.format.bracketSpacing\": false,\n}\n</code></pre></p>"},{"location":"troubleshooting/#not-here","title":"Not here?","text":"<p>Create a new issue in the project's issues</p>"}]}